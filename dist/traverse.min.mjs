var e={d:(t,s)=>{for(var r in s)e.o(s,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:s[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{A:()=>r});const s=new WeakMap;function r(e){return s.get(e)??function(e){let t=1;class r{static NONE=0;static EXTERNPROTO_DECLARATIONS=t;static PROTO_DECLARATIONS=t<<=1;static ROOT_NODES=t<<=1;static IMPORTED_NODES=t<<=1;static EXTERNPROTO_DECLARATION_SCENE=t<<=1;static PROTO_DECLARATION_BODY=t<<=1;static PROTOTYPE_INSTANCES=t<<=1;static INLINE_SCENE=t<<=1;static ALL=(t<<1)-1;static traverse(t,s=this.NONE){const r=new Set;switch(!0){case t instanceof e.X3DExecutionContext:return this.#e(t,s,r);case t instanceof e.NamedNodesArray:case t instanceof e.ExternProtoDeclarationArray:case t instanceof e.ProtoDeclarationArray:case t instanceof e.MFNode:case Array.isArray(t):return this.#t(t,s,r);case t instanceof e.SFNode:return this.#s(t.getValue(),s,r);case t instanceof e.X3DBaseNode:return this.#s(t,s,r)}}static*#e(e,t,s){if(e){if(t&r.EXTERNPROTO_DECLARATIONS)for(const r of e.externprotos)yield*this.#s(r,t,s);if(t&r.PROTO_DECLARATIONS)for(const r of e.protos)yield*this.#s(r,t,s);t&r.ROOT_NODES&&(yield*this.#t(e.rootNodes,t,s)),yield e}}static*#t(t,s,r){for(const o of t)yield*this.#s(o instanceof e.SFNode?o.getValue():o,s,r)}static*#s(t,s,o){if(!t)return;if(o.has(t))return;o.add(t),yield*this.#r(t.getUserDefinedFields(),s,o),yield*this.#r(t.getPredefinedFields(),s,o);const n=t.getType();for(let i=n.length-1;i>=0;--i){switch(n[i]){case e.X3DConstants.X3DExternProtoDeclaration:s&this.EXTERNPROTO_DECLARATION_SCENE&&(yield*this.#e(t.getInternalScene(),s,o));break;case e.X3DConstants.X3DProtoDeclaration:s&r.PROTO_DECLARATION_BODY&&(yield*this.#e(t.getBody(),s,o));break;case e.X3DConstants.X3DPrototypeInstance:s&r.PROTOTYPE_INSTANCES&&(yield*this.#e(t.getBody(),s,o));break;case e.X3DConstants.Inline:s&this.INLINE_SCENE&&(yield*this.#e(t.getInternalScene(),s,o));break;default:continue}break}yield t instanceof e.X3DNode?e.SFNodeCache.get(t):t}static*#r(t,s,r){for(const o of t)switch(o.getType()){case e.X3DConstants.SFNode:yield*this.#s(o.getValue(),s,r);break;case e.X3DConstants.MFNode:yield*this.#t(o,s,r)}}static find(t,s,r=this.NONE){const o=new Set,n=new Set((Array.isArray(s)?s:[s]).map(t=>t instanceof e.SFNode&&t===e.SFNodeCache.get(t.getValue())?t.getValue().valueOf():t));return this.#o(t,n,r,[],o)}static*#o(e,t,s,r,o){if(e){if(r.push(e),t.has(e))yield r.slice();else{if(s&this.EXTERNPROTO_DECLARATIONS){const n=e.getExternProtoDeclarations();r.push("externprotos");for(const[e,i]of n.entries())yield*this.#n(i,t,s,r,o);r.pop()}if(s&this.PROTO_DECLARATIONS){const n=e.getProtoDeclarations();r.push("protos");for(const[e,i]of n.entries())r.push(e),yield*this.#n(i,t,s,r,o),r.pop();r.pop()}if(s&this.ROOT_NODES){const n=e.getRootNodes();r.push("rootNodes");for(const[e,i]of n.entries())r.push(e),yield*this.#n(i?.getValue(),t,s,r,o),r.pop();r.pop()}if(s&this.IMPORTED_NODES){r.push("importedNodes");for(const[n,i]of e.getImportedNodes().entries()){if(r.push(n),r.push(i),t.has(i))yield r.slice();else try{const e=i.getExportedNode();yield*this.#n(e,t,s,r,o)}catch(e){}r.pop(),r.pop()}r.pop()}}r.pop()}}static*#n(t,s,r,o,n){if(t&&!n.has(t)){if(n.add(t),o.push(t instanceof e.X3DNode?e.SFNodeCache.get(t):t),s.has(t.valueOf()))yield o.slice();else{t.getType().includes(e.X3DConstants.X3DExternProtoDeclaration)||(yield*this.#i(t.getUserDefinedFields(),s,r,o,n),yield*this.#i(t.getPredefinedFields(),s,r,o,n));const i=t.getType();for(let a=i.length-1;a>=0;--a)switch(i[a]){case e.X3DConstants.X3DExternProtoDeclaration:r&this.EXTERNPROTO_DECLARATION_SCENE&&(yield*this.#o(t.getInternalScene(),s,r,o,n));break;case e.X3DConstants.X3DProtoDeclaration:r&this.PROTO_DECLARATION_BODY&&(yield*this.#o(t.getBody(),s,r,o,n));break;case e.X3DConstants.X3DPrototypeInstance:r&this.PROTOTYPE_INSTANCES&&(yield*this.#o(t.getBody(),s,r,o,n));break;case e.X3DConstants.Inline:r&this.INLINE_SCENE&&(yield*this.#o(t.getInternalScene(),s,r,o,n))}}o.pop(),n.delete(t)}}static*#i(t,s,r,o,n){for(const i of t){if(o.push(i.getName()),s.has(i))yield o.slice();else switch(i.getType()){case e.X3DConstants.SFNode:yield*this.#n(i.getValue(),s,r,o,n);break;case e.X3DConstants.MFNode:for(const[e,t]of i.entries())o.push(e),yield*this.#n(t?.getValue(),s,r,o,n),o.pop()}o.pop()}}}return e.X3DExecutionContext.prototype.traverse=function(e=r.ROOT_NODES){return r.traverse(this,e)},e.X3DExternProtoDeclaration.prototype.traverse=function(e){return r.traverse(this,e)},e.X3DProtoDeclaration.prototype.traverse=function(e){return r.traverse(this,e)},e.NamedNodesArray.prototype.traverse=function(e){return r.traverse(this,e)},e.ExternProtoDeclarationArray.prototype.traverse=function(e){return r.traverse(this,e)},e.ProtoDeclarationArray.prototype.traverse=function(e){return r.traverse(this,e)},e.SFNode.prototype.traverse=function(e){return r.traverse(this,e)},e.MFNode.prototype.traverse=function(e){return r.traverse(this,e)},e.X3DExecutionContext.prototype.find=function(e,t=r.ROOT_NODES){return r.find(this,e,t)},s.set(e,r),r}(e)}const o=t.A;export{o as default};